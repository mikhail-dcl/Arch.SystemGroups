name: "Create Release"

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g., v1.0.0)'
        required: true
        type: string
      custom_description:
        description: 'Custom release description (optional - leave empty to auto-generate from PRs)'
        required: false
        type: string
      prerelease:
        description: 'Mark as pre-release'
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  pull-requests: read

jobs:
  create-release:
    name: Build and Create Release
    runs-on: ubuntu-latest
    env:
      DOTNET_CLI_TELEMETRY_OPTOUT: 1
      DOTNET_SKIP_FIRST_TIME_EXPERIENCE: 1
      DOTNET_NOLOGO: true

    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch all history for changelog generation

    - name: Setup .NET SDK
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: |
          6.0.x
          7.0.x

    - name: Restore
      run: dotnet restore

    - name: Build SourceGenerator (Release)
      run: dotnet build Arch.SystemGroups.SourceGenerator/Arch.SystemGroups.SourceGenerator.csproj --configuration Release --no-restore

    - name: Create SourceGenerator Unity Package
      run: |
        PACKAGE_DIR="com.arch.systemgroups.sourcegenerator"
        # Remove 'v' prefix from version if present
        PACKAGE_VERSION="${{ github.event.inputs.version }}"
        PACKAGE_VERSION="${PACKAGE_VERSION#v}"

        # Create package directory
        mkdir -p "$PACKAGE_DIR"

        # Copy SourceGenerator DLL
        cp Arch.SystemGroups.SourceGenerator/bin/Release/netstandard2.0/Arch.SystemGroups.SourceGenerator.dll "$PACKAGE_DIR/"

        # Create package.json
        cat > "$PACKAGE_DIR/package.json" << EOF
        {
          "name": "com.arch.systemgroups.sourcegenerator",
          "displayName": "Arch.SystemGroups SourceGenerator",
          "version": "$PACKAGE_VERSION",
          "unity": "2022.3",
          "description": "Source Generator for Arch.SystemGroups - generates boilerplate code for ECS systems",
          "keywords": ["unity", "ecs", "arch", "source-generator", "roslyn"],
          "homepage": "https://github.com/mikhail-dcl/Arch.SystemGroups",
          "bugs": {
            "url": "https://github.com/mikhail-dcl/Arch.SystemGroups/issues"
          },
          "repository": {
            "type": "git",
            "url": "git+ssh://git@github.com/mikhail-dcl/Arch.SystemGroups.git"
          },
          "license": "APACHE 2.0",
          "author": "mikhail-dcl (https://github.com/mikhail-dcl/)"
        }
        EOF

        # Create .meta file with RoslynAnalyzer configuration
        cat > "$PACKAGE_DIR/Arch.SystemGroups.SourceGenerator.dll.meta" << 'EOF'
        fileFormatVersion: 2
        guid: a1b2c3d4e5f6789012345678901234ab
        labels:
        - RoslynAnalyzer
        PluginImporter:
          externalObjects: {}
          serializedVersion: 2
          iconMap: {}
          executionOrder: {}
          isPreloaded: 0
          isOverridable: 0
          isExplicitlyReferenced: 0
          platformData:
          - first:
              Editor: Editor
            second:
              enabled: 1
              settings:
                CPU: AnyCPU
                DefaultValueInitialized: true
                OS: AnyOS
          - first:
              Any:
            second:
              enabled: 0
              settings: {}
          userData:
          assetBundleName:
          assetBundleVariant:
        EOF

        # Create tarball (UPM format)
        tar -czf "com.arch.systemgroups.sourcegenerator-$PACKAGE_VERSION.tgz" -C "$PACKAGE_DIR" .

        echo "âœ… Unity package created: com.arch.systemgroups.sourcegenerator-$PACKAGE_VERSION.tgz"
        echo "PACKAGE_VERSION=$PACKAGE_VERSION" >> $GITHUB_ENV
        echo "PACKAGE_FILE=com.arch.systemgroups.sourcegenerator-$PACKAGE_VERSION.tgz" >> $GITHUB_ENV

    - name: Run Tests
      run: dotnet test --configuration Release --no-restore --logger trx --results-directory "TestResults"

    - name: Generate Release Notes
      id: release_notes
      uses: actions/github-script@v7
      with:
        result-encoding: string
        script: |
          const customDescription = `${{ github.event.inputs.custom_description }}`;

          // If custom description provided, use it
          if (customDescription && customDescription.trim() !== '') {
            return customDescription;
          }

          // Otherwise, generate from merged PRs
          const repo = context.repo;

          // Get the latest release
          let lastReleaseDate;
          try {
            const { data: latestRelease } = await github.rest.repos.getLatestRelease({
              owner: repo.owner,
              repo: repo.repo,
            });
            lastReleaseDate = latestRelease.created_at;
          } catch (error) {
            // No previous release, use repo creation date or a far back date
            lastReleaseDate = '2020-01-01T00:00:00Z';
          }

          // Get merged PRs since last release
          const { data: pullRequests } = await github.rest.pulls.list({
            owner: repo.owner,
            repo: repo.repo,
            state: 'closed',
            sort: 'updated',
            direction: 'desc',
            per_page: 100
          });

          const mergedPRs = pullRequests.filter(pr =>
            pr.merged_at &&
            new Date(pr.merged_at) > new Date(lastReleaseDate)
          );

          if (mergedPRs.length === 0) {
            return '## Changes\n\nNo merged pull requests since last release.';
          }

          // Group PRs by type based on title/labels
          const features = [];
          const bugFixes = [];
          const other = [];

          for (const pr of mergedPRs) {
            const title = pr.title.toLowerCase();
            const labels = pr.labels.map(l => l.name.toLowerCase());

            const prLink = `- ${pr.title} (#${pr.number}) @${pr.user.login}`;

            if (title.startsWith('feat') || labels.includes('enhancement') || labels.includes('feature')) {
              features.push(prLink);
            } else if (title.startsWith('fix') || labels.includes('bug') || labels.includes('bugfix')) {
              bugFixes.push(prLink);
            } else {
              other.push(prLink);
            }
          }

          // Build release notes
          let notes = '## What\'s Changed\n\n';

          if (features.length > 0) {
            notes += '### âœ¨ Features\n' + features.join('\n') + '\n\n';
          }

          if (bugFixes.length > 0) {
            notes += '### ðŸ› Bug Fixes\n' + bugFixes.join('\n') + '\n\n';
          }

          if (other.length > 0) {
            notes += '### ðŸ”§ Other Changes\n' + other.join('\n') + '\n\n';
          }

          notes += `\n**Full Changelog**: https://github.com/${repo.owner}/${repo.repo}/compare/${lastReleaseDate.split('T')[0]}...${{ github.event.inputs.version }}`;

          return notes;

    - name: Create Release
      uses: actions/github-script@v7
      env:
        RELEASE_NOTES: ${{ steps.release_notes.outputs.result }}
      with:
        script: |
          const fs = require('fs');
          const repo = context.repo;

          // Create the release
          const { data: release } = await github.rest.repos.createRelease({
            owner: repo.owner,
            repo: repo.repo,
            tag_name: '${{ github.event.inputs.version }}',
            name: '${{ github.event.inputs.version }}',
            body: process.env.RELEASE_NOTES,
            draft: false,
            prerelease: ${{ github.event.inputs.prerelease }},
            target_commitish: context.sha
          });

          console.log(`Release created: ${release.html_url}`);

          // Upload the SourceGenerator DLL as a release asset
          const dllPath = 'Arch.SystemGroups.SourceGenerator/bin/Release/netstandard2.0/Arch.SystemGroups.SourceGenerator.dll';
          const dllContent = fs.readFileSync(dllPath);

          await github.rest.repos.uploadReleaseAsset({
            owner: repo.owner,
            repo: repo.repo,
            release_id: release.id,
            name: 'Arch.SystemGroups.SourceGenerator.dll',
            data: dllContent,
          });

          console.log('SourceGenerator DLL uploaded successfully');

          // Upload the Unity Package as a release asset
          const packageFile = process.env.PACKAGE_FILE;
          const packageContent = fs.readFileSync(packageFile);

          await github.rest.repos.uploadReleaseAsset({
            owner: repo.owner,
            repo: repo.repo,
            release_id: release.id,
            name: packageFile,
            data: packageContent,
          });

          console.log('Unity Package uploaded successfully');
          console.log(`ðŸ“¦ Unity Package URL: ${release.html_url.replace('/tag/', '/download/')}/${packageFile}`);

          // Also create a summary
          await core.summary
            .addHeading('Release Created Successfully! ðŸŽ‰')
            .addLink('View Release', release.html_url)
            .addRaw('\n\n')
            .addHeading('Release Details', 3)
            .addList([
              `Version: ${{ github.event.inputs.version }}`,
              `Pre-release: ${{ github.event.inputs.prerelease }}`,
              `Assets: Arch.SystemGroups.SourceGenerator.dll, ${packageFile}`
            ])
            .addRaw('\n\n')
            .addHeading('Unity Package Manager Installation', 3)
            .addRaw(`\n\nTo install the SourceGenerator in Unity, add this URL to Package Manager:\n\n`)
            .addCodeBlock(`${release.html_url.replace('/tag/', '/download/')}/${packageFile}`, 'text')
            .write();
