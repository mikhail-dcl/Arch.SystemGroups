# Arch.SystemGroups

[![License](https://img.shields.io/badge/License-Apache_2.0-blue.svg?style=for-the-badge)](https://opensource.org/licenses/Apache-2.0)
![C#](https://img.shields.io/badge/c%23-%23239120.svg?style=for-the-badge&logo=c-sharp&logoColor=white)


The project provides extensions for the [Arch.System](https://github.com/genaray/Arch.Extended) tailored to the Unity Player Loop.
It is inspired by [Unity Entities' System Groups](https://docs.unity3d.com/Packages/com.unity.entities@1.0/manual/systems-update-order.html)


## Installation

- Make sure Unity 2022.2.9f1 is installed (the project is linked against this version)
- Create a release build
- Copy `Arch.SystemGroups.dll` into `Plugins` directory of your Unity project.
- Copy `Arch.SystemGroups.SourceGenerator.dll` into the desired directory of your project, exclude all platforms, add a new Label "RoslynGenerator" to the assembly (see [Unity docs](https://docs.unity3d.com/Manual/roslyn-analyzers.html) for more information)

## Update In Group

Use the `UpdateInGroup` attribute on the member systems to specify which systems need to be updated in a given group.
When the attribute is specified for class that implements `Arch.System.ISystem<float>` a partial class for the given system is generated.
It contains methods to add a system to the `World Builder` with respect to its update order.

> Note: Only systems that implement `Arch.System.ISystem<float>` are supported as the `float` denotes Delta Time from the Unity Player Loop.

`UpdateInGroup` accepts as a constructor argument a type of the system group or a custom group.

### System Groups

By default `Arch` Groups and Systems contain only `BeforeUpdate`, `AfterUpdate` and `Update` methods.
It's quite limiting and not aligned well with the [Unity Player Loop](https://docs.unity3d.com/ScriptReference/LowLevel.PlayerLoopSystem.html).

System groups extend this capability and provide a predefined set of groups that are bound to a specific moment in the Unity Player Loop.
Every custom group and system in order to get updated must be a child of one of the system groups directly or transitively.

#### Initialization System Group

Updates at the end of the Initialization phase of the player loop. `Time.deltaTime` is passed as an argument.

```csharp
[UpdateInGroup(typeof(InitializationSystemGroup))]
```

#### Simulation System Group

Updates at the end of the Update phase of the player loop. `Time.deltaTime` is passed as an argument.

You would normally use this group as an alternative to the `Update` method of the `MonoBehaviour` class.

```csharp
[UpdateInGroup(typeof(SimulationSystemGroup))]
```

#### Presentation System Group

Updates at the end of the PreLateUpdate phase of the player loop. `Time.deltaTime` is passed as an argument.

You would normally use this group as an alternative to the `LateUpdate` method of the `MonoBehaviour` class.

```csharp
[UpdateInGroup(typeof(PresentationSystemGroup))]
```

#### Post Rendering System Group

Updates at the end of the PostLateUpdate phase of the player loop (after Rendering). `Time.deltaTime` is passed as an argument.

```csharp
[UpdateInGroup(typeof(PostRenderingSystemGroup))]
```

#### Physics System Group

Updates at the beginning of the FixedUpdate phase of the player loop before all fixed updates. `Time.fixedDeltaTime` is passed as an argument.

You would normally use this group as an alternative to the `FixedUpdate` method of the `MonoBehaviour` class (e.g. to assign `Velocity` to the objects that move in the current frame).

```csharp
[UpdateInGroup(typeof(PhysicsSystemGroup))]
```

#### Post Physics System Group

Updates at the end of the FixedUpdate phase of the player loop.

```csharp
[UpdateInGroup(typeof(PostPhysicsSystemGroup))]
```

### Custom Groups
Groups are created automatically on [systems creation](#how-to-instantiate-systems). The method `TryCreateGroup<T>(ref ArchSystemsWorldBuilder<T> worldBuilder)` will be generated but you can just ignore it as it should be called from other generated code only.
#### Default Behaviour
To create a custom group declare an empty `partial` class and annotate it with `UpdateInGroup` attribute. The logic needed for ordering and assigning systems to the group will be autogenerated.

```csharp
[UpdateInGroup(typeof(InitializationSystemGroup))]
public partial class CustomGroup1
{
    
}
```

#### Custom Behaviour
In some cases it can be useful to provide custom behavior for groups. For example, you might want to create a group that runs at a reduced frequency.

To do so instead of creating an empty `partial` class, create a class that inherits from `Arch.SystemGroups.CustomGroupBase` and annotate it with `UpdateInGroup` attribute.

```csharp
/// <summary>
/// Skips every other update
/// </summary>
public class ThrottleGroupBase : CustomGroupBase<float>
{
    private bool open;
    
    public override void Dispose()
    {
        DisposeInternal();
    }

    public override void Initialize()
    {
        InitializeInternal();
    }

    public override void BeforeUpdate(in float t)
    {
        // Before Update is always called first in the same frame
        open = !open;
        
        if (open)
            BeforeUpdateInternal(in t);
    }

    public override void Update(in float t)
    {
        if (open)
            UpdateInternal(in t);
    }

    public override void AfterUpdate(in float t)
    {
        if (open)
            AfterUpdateInternal(in t);
    }
}
```

> If a group does not belong to a `System Group` then it is detached from the Player Loop and its system won't be updated

## Update Order

Systems update order is controlled by `UpdateAfter` and `UpdateBefore` attributes.
- Both systems and groups can be annotated with these attributes.
- Only systems and groups annotated by `UpdateInGroup` are taken into consideration
- `UpdateAfter` and `UpdateBefore` can't contain an open generic type (e.g. `typeof(CustomSystem<>)`). If you have such need, create a custom group and annotate the system with `UpdateInGroup` attribute.
- It is possible to have several of them
- it is possible to place redundant attributes, they will be properly resolved/ignored
- As an argument attributes accept the system or group type
- **Depth first search** is used to sort systems; [System Groups](#system-groups) act as root nodes.
- Sorting happens only once on [Systems Instantiation](#how-to-instantiate-systems)


## How to instantiate systems
In order to bind systems to the player loop, distribute them in groups and sort accordingly, one must use auto-generated API. 
The API is generated for non-abstract generic and non-generic systems that implement `Arch.System.ISystem<float>`.

1. Instantiate `ArchSystemsWorldBuilder` with a desired type of `World`. With `Arch` you are most probably using `Arch.Core.World`

    ```csharp
    var worldBuilder = new ArchSystemsWorldBuilder<World>(World.Create());
    ```

   The system must have a constructor with a first argument of the World type.

    ```csharp
    [UpdateInGroup(typeof(InitializationSystemGroup))]
    [UpdateBefore(typeof(CustomGroup1))]
    public partial class CustomSystem1 : BaseSystem<World, float>
    {
        public CustomSystem1(World world) : base(world)
        {
        }
    }
    ```

2. Add systems to the builder. There are multiple ways of doing so:
   - Use a static `Factory Method` `InjectToWorld` of the system and pass `worldBuilder` as `ref`     
      ```csharp
      CustomSystem1.InjectToWorld(ref worldBuilder);
      ```
     If the system has arguments pass the corresponding arguments as well
      ```csharp
        [UpdateInGroup(typeof(InitializationSystemGroup))]
        public partial class CustomSystemWithParameters1 : BaseSystem<TestWorld, float>
        {
            private readonly string _param1;
            private readonly int _param2;
     
            public CustomSystemWithParameters1(TestWorld world, string param1, int param2) : base(world)
            {
                 _param1 = param1;
                 _param2 = param2;
            }
        }
      ```

      ```csharp
      CustomSystemWithParameters1.InjectToWorld(ref worldBuilder, "test", 1);
      ```
   - Invoke Extensions. For every system an extension method is generated `Add{SystemName}({Arguments})`. If you rename the system you will have to modify the code accordingly manually.
      ```csharp
      worldBuilder.AddCustomSystemWithParameters1("test", 1)
      ```
   - Bulk creation. If you have many systems sharing the same constructor's signature using a bulk instantiation may be particularly beneficial
      
     Instead of writing something like
      ```csharp
     worldBuilder
            .AddSystemCGroupAA()
            .AddSystemCGroupAB()
            .AddSystemAGroupAA()
            .AddSystemAGroupAB()
            .AddSystemBGroupAA()
            .AddSystemBGroupAB()

            .AddSystemDGroupBA()
            .AddSystemCGroupBA()
            .AddSystemCGroupBAA()
            .AddSystemBGroupBA()
            .AddSystemBGroupBB()
            .AddSystemBGroupBAA()
            .AddSystemAGroupBA()
            .AddSystemAGroupBB()
            .AddSystemAGroupBAA()
            .AddSystemAGroupBAB();
      ```
     you can simply write an equivalent that will inject all systems (here all the systems are without any arguments) at once: 
      ```csharp
      worldBuilder.AddAllSystems();
      ```
     For every arguments set a separate extension is generated so you can chain them like this:
     ```csharp
      worldBuilder
          .AddAllSystems(new CustomClass1())
          .AddAllSystems("test", 1)
          .AddAllSystems(1.0, (f, i) => { })
     ```

     > For generic systems such extensions are not generated. You will have to use the `Factory Method` or `AddSystem` extension
3. Add as many systems as needed
4. Call `var groupWorld = worldBuilder.Finish()` to create all groups and systems, and sort them
5. Call `groupWorld.Initialize()` to recursively initialize systems, it will be called in accordance to `Update Order`
6. From this point all your systems are attached to the Unity Player Loop
7. Once the `World` should be disposed, call `groupWorld.Dispose()` to detach systems from the Player Loop